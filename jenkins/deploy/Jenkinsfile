def animal = "cat"

pipeline {
    agent {
        label 'ph02-syrah-rhel8'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
        ansiColor('xterm')
    }

    // A variable defined in environment block is available through all stages
    // and its value cannot be changed later.
    environment {
        SPACK_RELEASE = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys spack_release').trim()
        STACK_RELEASE = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys stack_release').trim()
        WORK_DIR = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys work_directory').trim()
        STACK_PREFIX = "${WORK_DIR}/${STACK_RELEASE}"
        PYTHON_VENV = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys python_venv').trim()
        PYTHON_VIRTUALENV_PATH = "${WORK_DIR}/${STACK_RELEASE}/${PYTHON_VENV}"
        ENVIRONMENTS = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments').trim()
        JENKINS_SCRIPTS_PATH = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys jenkins_scripts_path').trim()
        STACK_RELEASE_VER = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys stack_version').trim()
        SPACK_PATH = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys spack').trim()
        STACK_INSTALL_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_INSTALL_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_EXTENSION = sh(returnStdout:true, script:'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys extensions').trim()
        SPACK_USER_CONFIG_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_EXTENSION}
}

    // A variable defined in a stage is bound to that stage.
    stages {

       stage('Print variables') {
            steps {
                echo "STACK_RELEASE: $STACK_RELEASE"
                echo "WORK_DIR: $WORK_DIR"
                echo "STACK_PREFIX: $STACK_PREFIX"
                echo "PYTHON_VIRTUALENV_PATH: ${PYTHON_VIRTUALENV_PATH}"
                echo "JENKINS_SCRIPTS_PATH: ${JENKINS_SCRIPTS_PATH}"
                echo "STACK_INSTALL_PATH: ${STACK_INSTALL_PATH}"
                echo "SPACK_INSTALL_PATH: ${SPACK_INSTALL_PATH}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "SPACK_USER_CONFIG_PATH: ${SPACK_USER_CONFIG_PATH}"
            }   
        }

        stage('Install Python Environment') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/update_production_configuration.sh'
            }
        }

        stage('Clone Spack') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/install_spack.sh'
            }
        }

        stage('Clone spack-sdploy') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/install_spack_sdploy.sh'
            }
        }

        stage('Configure spack-sdploy') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/configure_spack_sdploy.sh'
            }
        }

        stage('Create Spack environments') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/create_spack_environments.sh'
            }
        }

        stage('Install compilers') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/install_compilers.sh'
            }
        }


//      stage('Echo') {
//            steps {
//                // env. is optional, but good practice
//                echo "BUILD_NUMBER = ${env.BUILD_NUMBER}"
//                sh 'echo PATH = $PATH'
//                sh "echo PATH = $PATH"
//                echo "animal: $animal"
//            }
//        }
//
//      stage('Export variables') {
//            steps {
//                sh "${JENKINS_SCRIPTS_PATH}/activate_spack.sh"
//                sh 'echo $PATH'
//                // This variable must be changed inside a script block !
//                script {
//                    animal = "dog"
//                }
//            }   
//        }
//
//      stage('Export variables 2') {
//            steps {
//                sh "${JENKINS_SCRIPTS_PATH}/config.sh"
//                sh 'echo $PATH'
//                echo "animal: $animal"
//            }   
//        }
//
//      stage('Error') {
//            steps {
//                catchError(message:'Error, but ok', buildResult:'Unstable', stageResult:'unstable') {
//                    sh "which python"
//                }
//            }
//        }
//
//      stage('Stage after Error') {
//            steps {
//                echo "after error"
//            }   
//        }
//
//      stage('Use run.sh') {
//            steps {
//                script {
//                    python_path = "${sh (script: 'jenkins/deploy/scripts/run.sh which python', returnStdout: true).trim()}".split('\n')
//                    yareed_path = "${sh (script: 'jenkins/deploy/scripts/run.sh which yareed', returnStdout: true).trim()}".split('\n')
//                    environemnts = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')
//                }
//            print("python: $python_path")
//            print("yareed: $yareed_path")
//            print("environments: $environemnts")
//            print("HERE")
//            sh 'echo $TEST_SPACK_ROOT'
//            sh 'echo $SOME_VAR'
//            }
//        }

       stage('Test my groovy function') {
            steps {
                script {
                    my_groovy_script('edu')
                }
            }   
        }

//        stage('Install compilers') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/install_compilers.sh'
//            }
//        }

//        stage('DELETE ALL DATA') {
//            steps {
//                sh 'rm -rf ${STACK_PREFIX}'
//            }
//        }

//        stage('A parallel stage test') {
//            steps {
////              script {
//                    parallel(some_stuff())
//                }
//            }
//        }
//
//        stage('A parallel stage') {
//            steps {
//                script {
//                    parallel(do_parallel_stage_1())
//                }
//            }
//        }
    }
}


def my_groovy_script(my_param) {

    param1 = "eduardo"
    def param2 = "eduardo2"

    println("print a simple string")
    println("1: " + param1)
    println("2: " + param2)
    println("3: ${param1}")
    println("4: ${param2}")
    println("5: " + my_param)
    println("6: ${my_param}")

    def environments = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    print(environments)
    println(environments)

    for (def environment in environments) {
        print environment
    }

}

def get_prefix(branch_name, stack_name) {
    def pattern = ~"origin/(packages|bugfix|features)/$stack_name/"
    if ("${branch_name}" =~ pattern) {
        println("PR detected")
        return "${env.HOME}/${stack_name}/pr/${env.BUILD_TAG}"
    }
    println("NO PR detected for branch ${branch_name}")
    return ""
}

def get_agent_name(environment) {
    agent_name = 'ph02-syrah-rhel8'   
    return agent_name
}

def _define_stages(prefix, script, message, do_junit = true) {

    environments = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    def jobs = [:]

    prinln('INSIDE LOOP')
    for (def environment in environments) {

        def agent_name = get_agent_name(environment)

        // Reporting
        println('Agent Name: ' + agent_name)
        println('Environment: ' + environment)

        jobs["${prefix}-${agent_name}"] = {

            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    env.environment = environment
                    env.script = script
                    def result = ''
                    checkout scm
                    try {
                        ansiColor('xterm') {
                            sh '${script}'
                        }
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: "${message} failed for ${environment}. ${env.BUILD_URL} with error ${error}"
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    if (do_junit) {
                        junit testResults:'*.xml',
                            allowEmptyResults: true
                    }
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def do_parallel_stage_1() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/parallel_stage1.sh",
                          "Run a stage in parallel")
}

def some_stuff() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/some_test.sh",
                          "Run a stage in parallel")
}