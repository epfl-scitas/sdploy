
pipeline {
    agent {
        label 'ph02-syrah-rhel8'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
        ansiColor('xterm')
    }

    // A variable defined in environment block is available through all stages
    // and its value cannot be changed later.
    environment {

        // <!> can't figure out where the ${STACK} variable comes from <!>
        STACK = "syrah-lite-l1"

        // Variables read from commons.yaml using cat, grep and cut.
        WORK_DIR=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep work_directory: | cut -n -d " " -f 2').trim()
        STACK_RELEASE=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_release: | cut -n -d " " -f 2').trim()
        PYTHON_VENV=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep python_venv: | cut -n -d " " -f 2').trim()
        SPACK_RELEASE = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_release: | cut -n -d " " -f 2').trim()
        SPACK_EXTENSION = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep extensions: | cut -n -d " " -f 2').trim()
        STACK_RELEASE_VER = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_version: | cut -n -d " " -f 2').trim()
        SPACK_PATH = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack: | cut -n -d " " -f 2').trim()
        SPACK_SDPLOY = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_sdploy: | cut -n -d " " -f 2').trim()

        // This variable makes sens to be hardcoded here.
        JENKINS = "jenkins/deploy/scripts"

        // Composed variables (from above values).
        PYTHON_VIRTUALENV_PATH = "${WORK_DIR}/${STACK_RELEASE}/${PYTHON_VENV}"
        STACK_PREFIX           = "${WORK_DIR}/${STACK_RELEASE}"
        STACK_INSTALL_PATH     = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_INSTALL_PATH     = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_SYSTEM_CONFIG_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_EXTENSION}"
        SPACK_SDPLOY_INSTALL_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_SDPLOY}"
        SPACK_DEFAULT_CONFIG_PATH = "${SPACK_INSTALL_PATH}/etc/spack"
    }

    // A variable defined in a stage is bound to that stage.
    stages {

//        stage('Do a fresh restart') {
//            steps {
//                sh 'echo STACK_PREFIX: ${STACK_PREFIX}'
//                sh 'rm -rf ${STACK_PREFIX}'
//            }
//         }

//     stage('Temporary clear file') {
//         steps {
//             sh 'rm -rf /home/scitasbuildpr/jenkins/workspace/spack.syrah.test.deploy@4/compilers.ph02-avx2.xml'
//             sh 'rm -rf /home/scitasbuildpr/jenkins/workspace/spack.syrah.test.deploy@4/compilers.ph02-avx.xml'
//         }
//     }

//     stage('Remove spack.yaml') {
//          steps {
//              sh 'rm /home/scitasbuildpr/syrah-lite/spack.v1/var/spack/environments/ph02_avx/spack.yaml'
//              sh 'rm /home/scitasbuildpr/syrah-lite/spack.v1/var/spack/environments/ph02_avx2/spack.yaml'
//          }
//     }

//     stage('Clear spack-config modules.yaml file') {
//          steps {
//              sh 'rm -rf /home/scitasbuildpr/syrah-lite/spack-config/modules.yaml'
//          }
//     }


        stage('Clear home directory') {
             steps {
                 sh 'rm -rf /home/scitasbuildpr/.spack'
             }
        }

        stage('Print variables') {
            steps {
                echo "The following values were read from common.yaml"
                echo "WORK_DIR: $WORK_DIR"
                echo "STACK_RELEASE: $STACK_RELEASE"
                echo "PYTHON_VIRTUALENV_PATH: ${PYTHON_VIRTUALENV_PATH}"
                echo "JENKINS: ${JENKINS}"
                echo "STACK: ${STACK}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "STACK_PREFIX: $STACK_PREFIX"
                echo "STACK_INSTALL_PATH: ${STACK_INSTALL_PATH}"
                echo "SPACK_INSTALL_PATH: ${SPACK_INSTALL_PATH}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "SPACK_SYSTEM_CONFIG_PATH: ${SPACK_SYSTEM_CONFIG_PATH}"
                echo "SPACK_SDPLOY_INSTALL_PATH: ${SPACK_SDPLOY_INSTALL_PATH}"
            }   
        }

        stage('Install Python Environment') {
            steps {
                sh '${JENKINS}/update_production_configuration.sh'
            }
        }

//        stage('Clear home environment') {
//            steps {
//                sh 'rm /home/scitasbuildpr/.spack/linux/*.yaml'
//            }
//        }

        stage('Install Spack') {  
            steps {
                sh '${JENKINS}/install_spack.sh'
            }
        }

        stage('Install Spack extensions') {
            steps {
                sh '${JENKINS}/install_spack_sdploy.sh'
            }
        }

//        stage('Install external repositories') {
//            steps {
//                sh '${JENKINS}/clone_external_repos.sh'
//            }
//        }

//        stage('Create Spack environments') {
//            steps {
//                sh '${JENKINS}/create_spack_environments.sh'
//            }
//        }
//
//        stage('Parallel stage') {
//            steps {
//                script {
//                    parallel(do_parallel_stage())
//                }
//            }
//        }
//
//        
//        stage('Deploy spack manifest') {
//            steps {
//                script {
//                    parallel(do_deploy_spack_configuration())
//                }
//            }
//        }
//
//        stage('Install compilers') {
//            steps {
//                script {
//                    parallel(do_install_compilers())
//                }
//            }
//        }
//
//       stage('Concretize') {
//           steps {
//               script {
//                   parallel(do_concretize())
//               }
//           }
//       }
//
//       stage('Populate mirror') {
//           steps {
//               sh 'jenkins/deploy/scripts/add_mirror.sh'
//           }
//       }
//
//       stage('Deploy software') { 
//           steps {
//               script {
//                  parallel(do_deploy())
//               }
//           }
//       }

    }
}


def groovy_script(my_param) {

    param1 = "eduardo"
    def param2 = "eduardo2"

    println("print a simple string")
    println("1: " + param1)
    println("2: " + param2)
    println("3: ${param1}")
    println("4: ${param2}")
    println("5: " + my_param)
    println("6: ${my_param}")

    def environments = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    for (def environment in environments) {
        print environment
    }

}

def get_prefix(branch_name, stack_name) {
    def pattern = ~"origin/(packages|bugfix|features)/$stack_name/"
    if ("${branch_name}" =~ pattern) {
        println("PR detected")
        return "${env.HOME}/${stack_name}/pr/${env.BUILD_TAG}"
    }
    println("NO PR detected for branch ${branch_name}")
    return ""
}

def get_agent_name(platform) {
    agent_name = platform + '-' + env.STACK_RELEASE + '-' + env.STACK_RELEASE_VER
    return agent_name
}

def _define_stages(prefix, script, message, do_junit = true) {

    def platforms = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/syrah-lite/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    def jobs = [:]
    for (def platform in platforms) {

        // THIS FUNCTIONS RETURNS THE CORRECT AGENT NAMES
        // - ONE AGENT NAME PER PLATFORM
        def agent_name = get_agent_name(platform)

        // Reporting
        // println('Agent Name: ' + agent_name)
        // println('Platform: ' + platform)
        // println('Agent Name: ' + agent_name)
        // println('Platform: ' + platform)

        jobs["${prefix}-${agent_name}"] = {

            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    env.environment = platform
                    env.script = script
                    def result = ''
                    checkout scm
                    try {
                        ansiColor('xterm') {
                            sh '${script}'
                        }
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: "${message} failed for ${platform}. ${env.BUILD_URL} with error ${error}"
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    if (do_junit) {
                        junit testResults:'*.xml',
                            allowEmptyResults: true
                    }
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def do_install_compilers() {
    return _define_stages("Install compilers",
                          "${env.JENKINS}/install_compilers.sh",
                          "Run a stage in parallel")
}

def do_deploy_spack_configuration() {
    return _define_stages("Deploy spack Configuration",
                          "${env.JENKINS}/deploy_spack_environment.sh",
                          "Run a stage in parallel")
}

def do_concretize() {
    return _define_stages("Concretize",
                          "${env.JENKINS}/concretize.sh",
                          "Concretization of stack")
}

def do_deploy() {
    return _define_stages("Deploy",
                          "${env.JENKINS}/install_stack.sh",
                          "Deployement of production stack")
}

def do_parallel_stage() {
    return _define_stages('Deploy',
                          'jenkins/deploy/scripts/parallel_stage1.sh',
                          'Deployement of production stack')
}
