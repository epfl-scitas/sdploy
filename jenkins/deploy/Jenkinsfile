
pipeline {
    agent {
        label 'ph02-syrah-rhel8'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
        ansiColor('xterm')
    }

    // A variable defined in environment block is available through all stages
    // and its value cannot be changed later.
    environment {

        // <!> can't figure out where the ${STACK} variable comes from <!>

        // Variables read from commons.yaml using cat, grep and cut.
        WORK_DIR=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep work_directory: | cut -n -d " " -f 2').trim()
        STACK_RELEASE=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_release: | cut -n -d " " -f 2').trim()
        PYTHON_VENV=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep python_venv: | cut -n -d " " -f 2').trim()
        SPACK_RELEASE = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_release: | cut -n -d " " -f 2').trim()
        SPACK_EXTENSION = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep extensions: | cut -n -d " " -f 2').trim()
        STACK_RELEASE_VER = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_version: | cut -n -d " " -f 2').trim()
        SPACK_PATH = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack: | cut -n -d " " -f 2').trim()
        SPACK_SDPLOY = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_sdploy: | cut -n -d " " -f 2').trim()

        // This variable makes sens to be hardcoded here.
        JENKINS = "jenkins/deploy/scripts"

        // Composed variables (from above values).
        PYTHON_VIRTUALENV_PATH = "${WORK_DIR}/${STACK_RELEASE}/${PYTHON_VENV}"
        STACK_PREFIX           = "${WORK_DIR}/${STACK_RELEASE}"
        STACK_INSTALL_PATH     = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_INSTALL_PATH     = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_USER_CONFIG_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_EXTENSION}"
        SPACK_SYSTEM_CONFIG_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_EXTENSION}"
        SPACK_SDPLOY_INSTALL_PATH = "${WORK_DIR}/${STACK_RELEASE}/${SPACK_SDPLOY}"
        SPACK_DEFAULT_CONFIG_PATH = "${SPACK_INSTALL_PATH}/etc/spack"
    }

    // A variable defined in a stage is bound to that stage.
    stages {

//      stage('Do a fresh restart') {
//          steps {

//              sh 'rm -rf ${STACK_PREFIX}'
//          }
//      }

//      stage('Temporary clear file') {
//          steps {
//              sh 'rm -rf /home/scitasbuildpr/jenkins/workspace/spack.syrah.test.deploy@4/compilers.ph02-avx2.xml'
//              sh 'rm -rf /home/scitasbuildpr/jenkins/workspace/spack.syrah.test.deploy@4/compilers.ph02-avx.xml'
//          }
//      }

//      stage('Clear spack-config modules.yaml file') {
//          steps {
//              sh 'rm -rf /home/scitasbuildpr/syrah-lite/spack-config/modules.yaml'
//          }
//      }

        stage('Print variables') {
            steps {
                echo "The following values were read from common.yaml"
                echo "WORK_DIR: $WORK_DIR"
                echo "STACK_RELEASE: $STACK_RELEASE"
                echo "PYTHON_VIRTUALENV_PATH: ${PYTHON_VIRTUALENV_PATH}"
                echo "JENKINS: ${JENKINS}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "STACK_PREFIX: $STACK_PREFIX"
                echo "STACK_INSTALL_PATH: ${STACK_INSTALL_PATH}"
                echo "SPACK_INSTALL_PATH: ${SPACK_INSTALL_PATH}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "SPACK_USER_CONFIG_PATH: ${SPACK_USER_CONFIG_PATH}"
                echo "SPACK_SYSTEM_CONFIG_PATH: ${SPACK_SYSTEM_CONFIG_PATH}"
                echo "SPACK_SDPLOY_INSTALL_PATH: ${SPACK_SDPLOY_INSTALL_PATH}"
            }   
        }

        stage('Install Python Environment') {
            steps {
                sh '${JENKINS}/update_production_configuration.sh'
            }
        }

        stage('Clone Spack') {
            steps {
                sh '${JENKINS}/install_spack.sh'
            }
        }

        stage('Clone spack-sdploy') {
            steps {
                sh '${JENKINS}/install_spack_sdploy.sh'
            }
        }

        stage('Configure spack-sdploy') {
            steps {
                sh '${JENKINS}/configure_spack_sdploy.sh'
            }
        }

        stage('Install external repositories') {
            steps {
                sh '${JENKINS}/clone_external_repos.sh'
            }
        }

        stage('Create Spack environments') {
            steps {
                sh '${JENKINS}/create_spack_environments.sh'
            }
        }

        stage('Deploy spack configuration') {
            steps {
                script {
                    parallel(do_deploy_spack_environment())
                }
            }
        }

        stage('Test my groovy function') {
            steps {
                script {
                    my_groovy_script('edu')
                }
            }   
        }

        stage('Install compilers') {
            steps {
                script {
                    parallel(do_install_compilers())
                }
            }
        }

       // CHECK THAT COMPILERS ARE LISTED IN COMPILERS.YAML
       // DEPLOY stack.yaml INTO OWN ENVIRONMENT DIRECTORY
       // DEPLOY THE OTHER CONFIGURATION FILES
       // - config.yaml
       // - repos.yaml
       // - packages.yaml
       // - modules.yaml
       // - mirrors.yaml

       stage('Conctretize') {
           steps {
               script {
                   parallel(do_concretize())
               }
           }
       }
    }
}


def my_groovy_script(my_param) {

    param1 = "eduardo"
    def param2 = "eduardo2"

    println("print a simple string")
    println("1: " + param1)
    println("2: " + param2)
    println("3: ${param1}")
    println("4: ${param2}")
    println("5: " + my_param)
    println("6: ${my_param}")

    def environments = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    for (def environment in environments) {
        print environment
    }

}

def get_prefix(branch_name, stack_name) {
    def pattern = ~"origin/(packages|bugfix|features)/$stack_name/"
    if ("${branch_name}" =~ pattern) {
        println("PR detected")
        return "${env.HOME}/${stack_name}/pr/${env.BUILD_TAG}"
    }
    println("NO PR detected for branch ${branch_name}")
    return ""
}

def get_agent_name(environment) {
    agent_name = 'ph02-syrah-rhel8'   
    return agent_name
}

def _define_stages(prefix, script, message, do_junit = true) {

    def environments = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    def jobs = [:]
    for (def environment in environments) {

        def agent_name = get_agent_name(environment)

        // Reporting
        println('Agent Name: ' + agent_name)
        println('Environment: ' + environment)

        jobs["${prefix}-${agent_name}-${environment}"] = {

            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    env.environment = environment
                    env.script = script
                    def result = ''
                    checkout scm
                    try {
                        ansiColor('xterm') {
                            sh '${script}'
                        }
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: "${message} failed for ${environment}. ${env.BUILD_URL} with error ${error}"
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    if (do_junit) {
                        junit testResults:'*.xml',
                            allowEmptyResults: true
                    }
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def do_install_compilers() {
    return _define_stages("Install compilers",
                          "${env.JENKINS}/install_compilers.sh",
                          "Run a stage in parallel")
}

def do_deploy_spack_environment() {
    return _define_stages("Deploy spack environment",
                          "${env.JENKINS}/deploy_spack_environment.sh",
                          "Run a stage in parallel")
}

def do_parallel_stage_1() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/parallel_stage1.sh",
                          "Run a stage in parallel")
}

def some_stuff() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/some_test.sh",
                          "Run a stage in parallel")
}

def do_concretize() {
    return _define_stages('Concretize',
                          'jenkins/deploy/scripts/concretize.sh',
                          'Concretization of stack')
}