pipeline {
    agent {
        label 'ph02-syrah-rhel8'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
        ansiColor('xterm')
    }

    // A variable defined in environment block is available through all stages
    // and its value cannot be changed later.
    environment {

        // <!> can't figure out where the ${STACK} variable comes from <!>
        // The following statement does nothing
        STACK = "syrah-lite-l2"

        // Variables read from commons.yaml using cat, grep and cut.
        WORK_DIR=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep work_directory: | cut -n -d " " -f 2').trim()
        STACK_RELEASE=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_release: | cut -n -d " " -f 2').trim()
        PYTHON_VENV=sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep python_venv: | cut -n -d " " -f 2').trim()
        SPACK_RELEASE = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_release: | cut -n -d " " -f 2').trim()
        SPACK_EXTENSION = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep extensions: | cut -n -d " " -f 2').trim()
        STACK_RELEASE_VER = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep stack_version: | cut -n -d " " -f 2').trim()
        SPACK_PATH = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack: | cut -n -d " " -f 2').trim()
        SPACK_SDPLOY = sh(returnStdout:true,
            script:'cat stacks/${STACK}/common.yaml |grep spack_sdploy: | cut -n -d " " -f 2').trim()

        // This variable makes sens to be hardcoded here.
        JENKINS = "jenkins/deploy/scripts"

        // Composed variables (from above values).
        STACK_PREFIX           = "${WORK_DIR}/${STACK_RELEASE}"
        PYTHON_VIRTUALENV_PATH = "${STACK_PREFIX}/${PYTHON_VENV}"
        SPACK_INSTALL_PATH     = "${STACK_PREFIX}/${SPACK_PATH}.${STACK_RELEASE_VER}"
        SPACK_SDPLOY_INSTALL_PATH = "${STACK_PREFIX}/${SPACK_SDPLOY}"
        SYSTEM_CONFIG_PREFIX      = "${STACK_PREFIX}/${STACK_RELEASE_VER}/config"
    }

    // A variable defined in a stage is bound to that stage.
    stages {

//        stage('Do a fresh restart') {
//            steps {
//                sh 'echo STACK_PREFIX: ${STACK_PREFIX}'
//                sh 'rm -rf ${STACK_PREFIX}'
//            }
//         }

        stage('Print variables') {
            steps {
                echo "The following values were read from common.yaml"
                echo "WORK_DIR: $WORK_DIR"
                echo "STACK_RELEASE: $STACK_RELEASE"
                echo "PYTHON_VIRTUALENV_PATH: ${PYTHON_VIRTUALENV_PATH}"
                echo "JENKINS: ${JENKINS}"
                echo "STACK: ${STACK}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "STACK_PREFIX: ${STACK_PREFIX}"
                echo "SPACK_INSTALL_PATH: ${SPACK_INSTALL_PATH}"
                echo "SPACK_RELEASE: ${SPACK_RELEASE}"
                echo "SPACK_SDPLOY_INSTALL_PATH: ${SPACK_SDPLOY_INSTALL_PATH}"
            }   
        }

        stage('Install Python Environment') {
            steps {
                sh '${JENKINS}/update_production_configuration.sh'
            }
        }

        stage('Install Spack') {  
            steps {
                sh '${JENKINS}/install_spack.sh'
            }
        }

        stage('Install Spack extensions') {
            steps {
                sh '${JENKINS}/install_spack_sdploy.sh'
            }
        }

        stage('Install External Repos') {
            steps {
                sh '${JENKINS}/clone_external_repos.sh'
            }
        }

        stage('Initialize Spack environments') {
            steps {
                script {
                    parallel(do_init_environments())
                }
            }
        }

        stage('Install compilers') {
            steps {
                script {
                    parallel(do_install_compilers())
                }
            }
        }

       stage('Concretize') {
           steps {
               script {
                   parallel(do_concretize())
               }
           }
       }

       stage('Populate mirror') {
           steps {
               sh '${JENKINS}/add_mirror.sh'
           }
       }

       stage('Deploy software') { 
           steps {
               script {
                  parallel(do_deploy())
               }
           }
       }

//      stage('Activate packages') {
//           steps {
//              script {
//                  parallel(activate_packages())
//              }
//          }
//      }
    }
}


def get_prefix(branch_name, stack_name) {
    def pattern = ~"origin/(packages|bugfix|features)/$stack_name/"
    if ("${branch_name}" =~ pattern) {
        println("PR detected")
        return "${env.HOME}/${stack_name}/pr/${env.BUILD_TAG}"
    }
    println("NO PR detected for branch ${branch_name}")
    return ""
}

def get_agent_name(platform) {
    agent_name = platform + '-' + env.STACK_RELEASE + '-' + env.STACK_RELEASE_VER
    return agent_name
}

def _define_stages(prefix, script, message, do_junit = false) {
    def platforms = "${sh (script: 'jenkins/deploy/scripts/run.sh yareed -file stacks/syrah-lite/common.yaml -keys environments',  returnStdout: true).trim()}".split('\n')

    def jobs = [:]
    for (def platform in platforms) {
        def agent_name = get_agent_name(platform)

        jobs["${prefix}-${agent_name}"] = {
            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    env.environment = platform
                    env.script = script
                    def result = ''
                    checkout scm
                    try {
                        ansiColor('xterm') {
                            sh '${script}'
                        }
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: "${message} failed for ${platform}. ${env.BUILD_URL} with error ${error}"
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    if (do_junit) {
                        junit testResults:'*.xml',
                            allowEmptyResults: true
                    }
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def do_deploy_spack_environment() {
    return _define_stages("Deploy spack Configuration",
                          "${env.JENKINS}/deploy_spack_environment.sh",
                          "Run a stage in parallel")
}

def do_init_environments() {
    return _define_stages("Initialize spack environments",
                          "${env.JENKINS}/init_environment.sh",
                          "Run a stage in parallel")
}


def do_install_compilers() {
    return _define_stages("Install compilers",
                          "${env.JENKINS}/install_compilers_parallel.sh",
                          "Run a stage in parallel",
			  true)
}


def do_concretize() {
    return _define_stages("Concretize",
                          "${env.JENKINS}/concretize.sh",
                          "Concretization of stack")
}

def do_deploy() {
    return _define_stages("Deploy",
                          "${env.JENKINS}/install_stack.sh",
                          "Deployement of production stack",
			  true)
}

def do_activate_packages() {
    return _define_stages('activate',
                          'jenkins/deploy/scripts/activate_packages.sh',
                          'Activation of packages')
}