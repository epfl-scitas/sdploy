def animal = "cat"

pipeline {
    agent {
        label 'ph02-syrah-rhel8'
    }

    // Adds timestamps to console logs
    options {
        timestamps()
        ansiColor('xterm')
    }

    environment {
        // define environment variables here for all steps
        STACK_RELEASE = "syrah"
        PYTHON_EXECUTABLE = "python3"
        SDPLOY_VIRTUALENV_PATH = "/home/scitasbuildpr/${STACK_RELEASE}/virtualenv/senv-py36"
        JENKINS_SCRIPTS_PATH = "jenkins/deploy/scripts"
        PYTHON_VIRTUALENV_PATH =  "/home/scitasbuildpr/${STACK_RELEASE}/py3-venv"
        STACK_PREFIX = "/home/scitasbuildpr/${STACK_RELEASE}"
    }

    // A variable defined in a stage is bound to that stage.
    // A variable defined in environment cannot be muttated in stages.

    stages {
//        stage('Install Python Environment') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/update_production_configuration.sh'
//            }
//        }
//
//        stage('Clone Spack') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/install_spack.sh'
//            }
//        }
//
//        stage('Clone spack-sdploy') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/install_spack_sdploy.sh'
//            }
//        }
//
//        stage('Configure spack-sdploy') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/configure_spack_sdploy.sh'
//            }
//        }
//
//        stage('Create Spack environments') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/create_spack_environments.sh'
//            }
//        }

       stage('Print environment') {
            steps {
                script {
                    sh "env"
                }
            }   
        }

      stage('Echo') {
            steps {
                // env. is optional, but good practice
                echo "BUILD_NUMBER = ${env.BUILD_NUMBER}"
                sh 'echo PATH = $PATH'
                sh "echo PATH = $PATH"
                echo "animal: $animal"
            }
        }

      stage('Export variables') {
            steps {
                sh "${JENKINS_SCRIPTS_PATH}/activate_spack.sh"
                sh 'echo $PATH'
                // This variable must be changed inside a script block !
                script {
                    animal = "dog"
                }
            }   
        }

      stage('Export variables 2') {
            steps {
                sh "${JENKINS_SCRIPTS_PATH}/config.sh"
                sh 'echo $PATH'
                echo "animal: $animal"
            }   
        }

      stage('Error') {
            steps {
                catchError(message:'Error, but ok', buildResult:'Unstable', stageResult:'unstable') {
                    sh "which python"
                }
            }
        }

      stage('Stage after Error') {
            steps {
                echo "after error"
            }   
        }

      stage('Use run.sh') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/run.sh which python'
                script {
                    python_path = "${sh (script: 'jenkins/deploy/scripts/run.sh which python', returnStdout: true).trim()}".split('\n')
                    yareed_path = "${sh (script: 'jenkins/deploy/scripts/run.sh which yareed', returnStdout: true).trim()}".split('\n')
                }
            echo "python: $python_path"
            echo "yareed: $yareed_path"
            }
        }


//        stage('Install compilers') {
//            steps {
//                sh '${JENKINS_SCRIPTS_PATH}/install_compilers.sh'
//            }
//        }

       stage('Test my groovy function') {
            steps {
                script {
                    my_groovy_script('edu')
                }
            }   
        }

        stage('Install compilers') {
            steps {
                sh '${JENKINS_SCRIPTS_PATH}/install_compilers.sh'
            }
        }

//        stage('DELETE ALL DATA') {
//            steps {
//                sh 'rm -rf ${STACK_PREFIX}'
//            }
//        }

//        stage('A parallel stage test') {
//            steps {
////              script {
//                    parallel(some_stuff())
//                }
//            }
//        }
//
//        stage('A parallel stage') {
//            steps {
//                script {
//                    parallel(do_parallel_stage_1())
//                }
//            }
//        }
    }
}


def my_groovy_script(my_param) {

    param1 = "eduardo"
    def param2 = "eduardo2"

    println("print a simple string")
    println("1: " + param1)
    println("2: " + param2)
    println("3: ${param1}")
    println("4: ${param2}")
    println("5: " + my_param)
    println("6: ${my_param}")

}

def get_prefix(branch_name, stack_name) {
    def pattern = ~"origin/(packages|bugfix|features)/$stack_name/"
    if ("${branch_name}" =~ pattern) {
        println("PR detected")
        return "${env.HOME}/${stack_name}/pr/${env.BUILD_TAG}"
    }
    println("NO PR detected for branch ${branch_name}")
    return ""
}

def get_agent_name(environment) {
    agent_name = 'ph02-syrah-rhel8'   
    return agent_name
}

def _define_stages(prefix, script, message, do_junit = true) {

    // environments == platforms
    // def environments = ['environment1']
    // def environments = "${sh (script: 'yareed --file stacks/common.yaml --keys environments', returnStdout: true).trim()}".split('\n')

    def environments = "${sh (script: 'jenkins/deploy/scripts/install_compilers.sh', returnStdout: true).trim()}".split('\n')

    println('Environments: ' + environments)
    // println environments

    def jobs = [:]

    prinln('INSIDE LOOP')
    for (def environment in environments) {

        def agent_name = get_agent_name(environment)

        // ER TESTING STUFF
        println('Agent Name: ' + agent_name)
        println('Environment: ' + environment)
        //println environment
        //println agent_name

        jobs["${prefix}-${agent_name}"] = {


            stage("${prefix}-${agent_name}") {
                node(agent_name) {
                    env.environment = environment
                    env.script = script
                    def result = ''
                    checkout scm
                    try {
                        ansiColor('xterm') {
                            sh '${script}'
                        }
                    } catch(error) {
                        result = error
                        currentBuild.result = 'FAILURE'
                        mattermostSend color: 'warning',
                            message: "${message} failed for ${environment}. ${env.BUILD_URL} with error ${error}"
                    }
                    archiveArtifacts artifacts:'*.txt, *.xml',
                        allowEmptyArchive: true
                    if (do_junit) {
                        junit testResults:'*.xml',
                            allowEmptyResults: true
                    }
                    if (result) {
                        throw(error)
                    }
                }
            }
        }
    }
    return jobs
}

def do_parallel_stage_1() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/parallel_stage1.sh",
                          "Run a stage in parallel")
}

def some_stuff() {
    return _define_stages("stage_1",
                          "${env.JENKINS_SCRIPTS_PATH}/some_test.sh",
                          "Run a stage in parallel")
}